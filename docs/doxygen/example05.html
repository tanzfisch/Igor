<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.8.8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Igor: Voxel Terrain Example</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr>
						<td id="projectlogo">                        
                            <div style="position: relative; height: 120px; width: 440px;">
                                <div style="position: absolute; float: right; right: 30px; bottom: 10px; z-index: 1000; background-color: transparent;">0.21.0</div>
                                <img alt="Logo" src="logo.png"></img>                            
                            </div>
                        </td>                            
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('example05.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Voxel Terrain Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>So in the voxel example we basically learn two things. One is how to use the class iVoxelData and the other is how to write and register a model data loader that derives from iModelDataIO (<a href="https://www.youtube.com/watch?v=EHBsmCx6gBM">youtube</a>).</p>
<h1>Build </h1>
<p>The code for this example can be found in the folder examples/05 Voxels. In a vs[ver] sub folder you will find a visual studio solution which contains example project but also all dependent projects. So you just open this one and than build and start. If everything went right you gonna see the following screen. If not please don't hesitate to contact <a href="https://github.com/tanzfisch">tanzfisch</a>.</p>
<div class="image">
<img src="Example05_Pic1.png" alt="Example05_Pic1.png"/>
<div class="caption">
Voxel Example</div></div>
<p> There is also a youtube clip <a href="https://youtu.be/EHBsmCx6gBM">Voxel Example</a>.</p>
<h1>Interaction</h1>
<ul>
<li>click left and drag to rotate the camera around the point of interest</li>
<li>press space to generate new voxel data</li>
</ul>
<h1>Code </h1>
<p>The most interesting parts in this example happen in the method generateVoxelData() and the class VoxelTerrainMeshGenerator. We start with generateVoxelData() because it initiates everything.</p>
<p>So first thing is to alloc some memory for the voxel data by creating a iVoxelData obejct and initializing it with the size we need. </p><pre class="fragment">    // if there is none create it
    if (_voxelData == nullptr)
    {
        _voxelData = new iVoxelData();
        // all voxels have a full density as default. so afterwars we need to cut holes in it
        _voxelData-&gt;setClearValue(255);
        _voxelData-&gt;initData(120, 120, 120);
    }
</pre><p>We generate a new random base everytime so every time we hit the space button we get a diffrent result. </p><pre class="fragment">    // generate new random base with time based seed
    _perlinNoise.generateBase(static_cast&lt;uint32&gt;(iTimer::getInstance().getTime()));
</pre><p>Clear the voxel data and switch to uncompressed mode for faster access. </p><pre class="fragment">    // clear the voxel data
    _voxelData-&gt;clear();
</pre><p>Define some thresholds for metaballs and caves. </p><pre class="fragment">    // define some threasholds to describe the surface of caves
    const float64 from = 0.444;
    const float64 to = 0.45;
    float64 factor = 1.0 / (to - from);

    // define some threasholds to describe the surface of metaballs
    const float64 fromMeta = 0.017;
    const float64 toMeta = 0.0175;
    float64 factorMeta = 1.0 / (toMeta - fromMeta);
</pre><p>Define some metaballs for the base structure </p><pre class="fragment">    // define some metaballs
    vector&lt;pair&lt;iaVector3f, float32&gt;&gt; metaballs;
    for (int i = 0; i &lt; 20; ++i)
    {
        metaballs.push_back(pair&lt;iaVector3f, float32&gt;(iaVector3f(rand() % static_cast&lt;int&gt;(_voxelData-&gt;getWidth() * 0.6) + (_voxelData-&gt;getWidth() * 0.2),
            rand() % static_cast&lt;int&gt;(_voxelData-&gt;getHeight()*0.6) + (_voxelData-&gt;getHeight()* 0.2),
            rand() % static_cast&lt;int&gt;(_voxelData-&gt;getDepth()*0.6) + (_voxelData-&gt;getDepth()*0.2)), (((rand() % 90) + 10) / 100.0) + 0.6));
    }
</pre><p>Now we itereate through and figure out if they are inside the metaballs and if that is true also if they are inside a cave. </p><pre class="fragment">    // now iterate through all the voxels and define their density
    for (int64 x = 0; x &lt; _voxelData-&gt;getWidth(); ++x)
    {
        for (int64 y = 0; y &lt; _voxelData-&gt;getHeight(); ++y)
        {
            for (int64 z = 0; z &lt; _voxelData-&gt;getDepth(); ++z)
            {
                // first figure out if a voxel is outside the sphere
                iaVector3f pos(x, y, z);

                float32 distance = 0;
                for (auto metaball : metaballs)
                {
                    distance += metaballFunction(metaball.first, pos) * metaball.second;
                }

                if (distance &lt;= toMeta)
                {
                    if (distance &gt;= fromMeta)
                    {
                        // at the edge of the sphere.
                        // now we can use the fractional part of the distance to determine how much more than a full voxel we are away from the center
                        // and use this to set the density. this way we get a smooth sphere.
                        float32 denstity = ((distance - fromMeta) * factorMeta);

                        // the density by the way goes from 0-255 but the zero is interpreted as outside ans the 1 is inside but with zero density
                        // so to calculate a propper density we need to multiply the density with 254 and to make it alwasy beein "inside" we add one
                        _voxelData-&gt;setVoxelDensity(iaVector3I(x, y, z), (denstity * 254) + 1);
                    }
                    else
                    {
                        // outside metaball
                        _voxelData-&gt;setVoxelDensity(iaVector3I(x, y, z), 0);
                    }
                }

                // using some perline noise to cut holes in the sphere. this time we skip the smoothing part due to much effort and cluttering the tutorial 
                // with bad understandable code. Ask the author if you'd like to know about smoothing the values
                float64 onoff = _perlinNoise.getValue(iaVector3d(pos._x * 0.03, pos._y * 0.03, pos._z * 0.03), 4, 0.5);

                // we do the same here as with the metaball surface so it a pears a little smoother
                if (onoff &lt;= from)
                {
                    if (onoff &gt;= to)
                    {
                        float64 gradient = 1.0 - ((onoff - from) * factor);
                        _voxelData-&gt;setVoxelDensity(iaVector3I(x, y, z), (gradient * 254) + 1);
                    }
                    else
                    {
                        _voxelData-&gt;setVoxelDensity(iaVector3I(x, y, z), 0);
                    }
                }
            }
        }
    }
</pre><p>The next major part is to turn the voxel data in to a mesh. We could just use the class iContouringCubes to do that but fore more comfort and to understand how to use it we go for implementing the iModelDataIO interface. The iModelDataIO interface is kind of a hock within the engine's loading process. We can define basically our own model data type, register it to the loading process and later just initialize an iNodeModel with our voxel data instead of a filename. So let's have a look at the key part of the VoxelTerrainMeshGenerator which implements that interface. </p><pre class="fragment">iNode* VoxelTerrainMeshGenerator::importData(const iaString&amp; sectionName, iModelDataInputParameter* parameter)
{
</pre><p>As you see we get besides the filename, which in our case is just any string, some extra input parameter that contain our voxel data information. See further down to initialize it with custom data. </p><pre class="fragment">    TileInformation* tileInformation = reinterpret_cast&lt;TileInformation*&gt;(parameter-&gt;_parameters.getDataPointer());
    iVoxelData* voxelData = tileInformation-&gt;_voxelData;
    int64 width = voxelData-&gt;getWidth() - 1;
    int64 depth = voxelData-&gt;getDepth() - 1;
    int64 height = voxelData-&gt;getHeight() - 1;
</pre><p>We create a resulting group node because the engine expects this from us. </p><pre class="fragment">    iNode* result = iNodeFactory::getInstance().createNode(iNodeType::iNode);
</pre><p>Now we use the iContouringCubes class to turn our voxel data in to a mesh. </p><pre class="fragment">    iContouringCubes contouringCubes;
    contouringCubes.setVoxelData(voxelData);
    shared_ptr&lt;iMesh&gt; mesh = contouringCubes.compile(iaVector3I(), iaVector3I(width, height, depth));
</pre><p>Theoretically the voxel data could result in a mesh that does not exists so we have to check that here. </p><pre class="fragment">    if (mesh.get() != nullptr)
    {
</pre><p>But if it does exist we create a iNodeMesh and add it to the resulting node. </p><pre class="fragment">        iNodeMesh* meshNode = static_cast&lt;iNodeMesh*&gt;(iNodeFactory::getInstance().createNode(iNodeType::iNodeMesh));
        meshNode-&gt;setMesh(mesh);
        meshNode-&gt;setMaterial(tileInformation-&gt;_materialID);
</pre><p>We also set up the target material of our mesh for tri planar texture mapping as defined earlier in material _voxelMeshMaterialID. </p><pre class="fragment">        iTargetMaterial* targetMaterial = meshNode-&gt;getTargetMaterial();
        targetMaterial-&gt;setTexture(iTextureResourceFactory::getInstance().requestFile("dirt.png"), 0);
        targetMaterial-&gt;setTexture(iTextureResourceFactory::getInstance().requestFile("grass.png"), 1);
        targetMaterial-&gt;setTexture(iTextureResourceFactory::getInstance().requestFile("rock.png"), 2);
        targetMaterial-&gt;setAmbient(iaColor3f(0.7f, 0.7f, 0.7f));
        targetMaterial-&gt;setDiffuse(iaColor3f(0.9f, 0.9f, 0.9f));
        targetMaterial-&gt;setSpecular(iaColor3f(0.1f, 0.1f, 0.1f));
        targetMaterial-&gt;setEmissive(iaColor3f(0.01f, 0.01f, 0.01f));
        targetMaterial-&gt;setShininess(100.0f);

        result-&gt;insertNode(meshNode);
    }

    return result;
}
</pre><p>And last but not least here is how we initialize our custom input parameters for loading our voxel data as a mesh iModelDataInputParameter. </p><pre class="fragment">// prepar special tile information for the VoxelTerrainMeshGenerator
TileInformation tileInformation;
tileInformation._materialID = _voxelMeshMaterialID;
tileInformation._voxelData = _voxelData;
// define the input parameter so Igor knows which iModelDataIO implementation to use and how
iModelDataInputParameter* inputParam = new iModelDataInputParameter();
inputParam-&gt;_identifier = "vtg";
inputParam-&gt;_joinVertexes = true;
inputParam-&gt;_needsRenderContext = false;
inputParam-&gt;_modelSourceType = iModelSourceType::Generated;
inputParam-&gt;_loadPriority = 0;
inputParam-&gt;_parameters.setData(reinterpret_cast&lt;const char*&gt;(&amp;tileInformation), sizeof(TileInformation));
// create a model node
iNodeModel* voxelMeshModel = static_cast&lt;iNodeModel*&gt;(iNodeFactory::getInstance().createNode(iNodeType::iNodeModel));
_voxelMeshModel = voxelMeshModel-&gt;getID();
// tell the model node to load data with specified identifier ans the above defined parameter
// it is important to have a unique identifier each time we generate a mesh otherwhise the cache system would return us a prvious generated mesh
voxelMeshModel-&gt;setModel(iaString("VoxelMesh") + iaString::itoa(_incarnation++), inputParam);
// create a transform node to center the mesh to the origin
iNodeTransform* voxelMeshTransform = static_cast&lt;iNodeTransform*&gt;(iNodeFactory::getInstance().createNode(iNodeType::iNodeTransform));
_voxelMeshTransform = voxelMeshTransform-&gt;getID();
voxelMeshTransform-&gt;translate(-_voxelData-&gt;getWidth() / 2, -_voxelData-&gt;getHeight() / 2, -_voxelData-&gt;getDepth() / 2);
// and add to scene
voxelMeshTransform-&gt;insertNode(voxelMeshModel);
_scene-&gt;getRoot()-&gt;insertNode(voxelMeshTransform);
</pre><h1>Additional Information </h1>
<p>Since the engine is capable of double precision size worlds we need to do an additional step that is kind of a workaround. At the bottom of the init method you can find the following lines. </p><pre class="fragment">// ok this one is kind of a workaround. In order to handle huge worlds beyond float precision we internally mess around with world positions.
// in consequence the world positions that end up in the shader are not valid. They are relative to the camera position. To compensate we can 
// set the world grid resolution here. It basically makes a modulo on the world coordinates so they never exceed float precision and are sort of usable again within a shader.
iRenderer::getInstance().setWorldGridResolution(1000.0);
</pre><p>And that's it. For further questions please contact <a href="https://github.com/tanzfisch">tanzfisch</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
		<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
			<ul>
				<li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
				<li class="footer">
					Generated by <a href="http://www.doxygen.org/index.html">
					<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8.
					Dark theme by <a href="http://majerle.eu" target="_new">Tilen Majerle</a>. All rights reserved.
				</li>
			</ul>
		</div>
		<script src="custom.js"></script>
	</body>
</html>